name: The Perseverance Engine v1.1

on:
  workflow_dispatch:

permissions:
  contents: write
  actions: write

jobs:
  main_loop:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        attempt: [1, 2, 3, 4, 5]
      fail-fast: false # مهم: لا توقف المحاولات الأخرى عند فشل واحدة

    steps:
      - name: "Attempt #${{ matrix.attempt }}: Design & Execute"
        id: current_attempt
        env:
          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
          GAME_DOWNLOAD_URL: "https://dl.cdn.freefiremobile.com/live/package/FreeFire.apk"
          # استرداد سجل المحاولة السابقة (إذا فشلت)
          PREVIOUS_ATTEMPT_LOG: ${{ needs.main_loop.outputs.attempt_log || 'This is the first attempt.' }}
        run: |
          # ----------------- BEGIN IN-LINE PYTHON SCRIPT -----------------
          python3 << 'EOF'
          import os, subprocess, json, sys

          # --- الجزء الأول: التصميم (استدعاء Gemini) ---
          print("--- DESIGNING SCRIPT ---")
          api_key = os.getenv("GOOGLE_API_KEY")
          download_url = os.getenv("GAME_DOWNLOAD_URL")
          previous_log = os.getenv("PREVIOUS_ATTEMPT_LOG")
          
          prompt_text = f"""
          You are a reverse engineering expert in a self-correcting loop. Goal: Generate a Python script to extract data from {download_url}.
          Previous Attempt Analysis: {previous_log}
          Your Task: Generate a NEW, IMPROVED Python script based on the failure. Use 'zipfile', then 'unzip', then 'AssetRipper'. Log everything to stdout. The script MUST create 'CORE_DATA' and exit with status 1 if it's empty.
          Generate ONLY the Python code inside ```python ... ```.
          """
          
          payload = {"contents": [{"parts": [{"text": prompt_text}]}]}
          curl_cmd = ["curl", "-s", "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-lite:generateContent", "-H", "Content-Type: application/json", "-H", f"x-goog-api-key: {api_key}", "-X", "POST", "-d", json.dumps(payload)]

          try:
              result = subprocess.run(curl_cmd, capture_output=True, text=True, check=True, timeout=90)
              response = json.loads(result.stdout)
              content = response["candidates"][0]["content"]["parts"][0]["text"]
              script_code = content.split("```python").split("```")[0].strip() if "```python" in content else content.strip()
              with open("miner_script.py", "w") as f:
                  f.write(script_code)
              print("Script 'miner_script.py' generated successfully.")
          except Exception as e:
              print(f"FATAL: Gemini call failed: {e}")
              # إذا فشل Gemini، لا يمكننا المتابعة. ننشئ سجل خطأ ونخرج.
              with open("attempt_log.txt", "w") as f:
                  f.write(f"Gemini API call failed. Cannot generate script. Error: {e}")
              sys.exit(1) # خروج بفشل

          # --- الجزء الثاني: التنفيذ ---
          print("\n--- EXECUTING GENERATED SCRIPT ---")
          try:
              subprocess.run(["chmod", "+x", "miner_script.py"], check=True)
              result = subprocess.run(["./miner_script.py"], capture_output=True, text=True, check=True)
              print("--- SCRIPT EXECUTED SUCCESSFULLY ---")
              with open("attempt_log.txt", "w") as f:
                  f.write(result.stdout)
              # بما أن السكربت نجح، نخرج من كود البايثون بنجاح (exit 0)
              
          except subprocess.CalledProcessError as e:
              print("--- SCRIPT FAILED AS EXPECTED (CORE_DATA likely empty) ---")
              # هذا هو الفشل "الجيد" الذي نريده. نجمع كل المعلومات لـ Gemini.
              error_log = f"STDOUT:\n{e.stdout}\n\nSTDERR:\n{e.stderr}"
              with open("attempt_log.txt", "w") as f:
                  f.write(error_log)
              sys.exit(1) # خروج بفشل لتشغيل المحاولة التالية
              
          except Exception as e:
              print(f"--- UNEXPECTED EXECUTION FAILURE ---")
              # فشل غير متوقع (مثل فشل chmod)
              with open("attempt_log.txt", "w") as f:
                  f.write(f"An unexpected error occurred during execution: {e}")
              sys.exit(1) # خروج بفشل
          EOF

      - name: "Store Attempt Log"
        # هذه الخطوة تعمل دائمًا لالتقاط سجل المحاولة
        if: always()
        id: store_log
        run: |
          # نقرأ محتويات السجل ونخرجها ليتم استخدامها في المحاولة التالية
          log_content=$(cat attempt_log.txt || echo "Log file not found.")
          echo "attempt_log=${log_content}" >> $GITHUB_OUTPUT