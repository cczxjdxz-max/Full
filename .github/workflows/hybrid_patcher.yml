name: FF SuperTool Build - Version 3.0

on:
  workflow_dispatch:

jobs:
  build_library:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup NDK
        uses: nttld/setup-ndk@v1
        with:
          ndk-version: r25c

      - name: Create C++ Source with Toast Support
        run: |
          mkdir -p jni
          cat << 'EOF' > jni/main.cpp
          #include <jni.h>
          #include <android/log.h>
          #include <sys/mman.h>
          #include <unistd.h>
          #include <string.h>
          #include <stdint.h>
          #include <stdlib.h>
          #include <pthread.h>

          // تعريف Logcat للتصحيح
          #define LOGI(...) __android_log_print(ANDROID_LOG_INFO, "OFFLINE_TOOL", __VA_ARGS__)

          uintptr_t il2cpp_base = 0;
          JavaVM* g_vm = nullptr;

          // دالة لإظهار رسالة Toast من داخل الـ C++
          void show_toast(JNIEnv* env) {
              jclass toast_class = env->FindClass("android/widget/Toast");
              jmethodID make_text = env->GetStaticMethodID(toast_class, "makeText", "(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast;");
              
              // الحصول على الـ Context (هذه الطريقة تعمل في معظم تطبيقات Unity)
              jclass unity_player = env->FindClass("com/unity3d/player/UnityPlayer");
              jfieldID activity_field = env->GetStaticFieldID(unity_player, "currentActivity", "Landroid/app/Activity;");
              jobject activity = env->GetStaticObjectField(unity_player, activity_field);

              jstring message = env->NewStringUTF("✅ تمت الإضافة بنجاح | Patched Successfully");
              jobject toast_obj = env->CallStaticObjectMethod(toast_class, make_text, activity, message, 0); // 0 = LENGTH_SHORT
              
              jmethodID show = env->GetMethodID(toast_class, "show", "()V");
              env->CallVoidMethod(toast_obj, show);
          }

          void patch_memory(uintptr_t address, const char* hex) {
              size_t size = strlen(hex) / 2;
              uintptr_t page_start = address & ~(getpagesize() - 1);
              mprotect((void*)page_start, getpagesize() * 2, PROT_READ | PROT_WRITE | PROT_EXEC);
              for (size_t i = 0; i < size; i++) {
                  char byte[3] = {hex[i*2], hex[i*2+1], '\0'};
                  ((uint8_t*)address)[i] = (uint8_t)strtol(byte, NULL, 16);
              }
          }

          uintptr_t get_module_base(const char* module_name) {
              FILE* fp = fopen("/proc/self/maps", "r");
              char line[512];
              uintptr_t base = 0;
              while (fp && fgets(line, sizeof(line), fp)) {
                  if (strstr(line, module_name)) {
                      base = strtoull(line, NULL, 16);
                      break;
                  }
              }
              if(fp) fclose(fp);
              return base;
          }

          void* injection_thread(void*) {
              while (il2cpp_base == 0) {
                  il2cpp_base = get_module_base("libil2cpp.so");
                  usleep(500000);
              }
              
              const char* hex_true = "200080D2C0035FD6";
              patch_memory(il2cpp_base + 0x315168c, hex_true); // Network
              patch_memory(il2cpp_base + 0x3184e38, hex_true); // Login
              patch_memory(il2cpp_base + 0x30bc4f0, hex_true); // Skins

              // استدعاء الـ Toast بعد نجاح الحقن
              JNIEnv* env;
              if (g_vm->AttachCurrentThread(&env, NULL) == JNI_OK) {
                  show_toast(env);
                  g_vm->DetachCurrentThread();
              }
              return NULL;
          }

          jint JNI_OnLoad(JavaVM* vm, void* reserved) {
              g_vm = vm;
              pthread_t ptid;
              pthread_create(&ptid, NULL, injection_thread, NULL);
              return JNI_VERSION_1_6;
          }
          EOF

          cat << 'EOF' > jni/Android.mk
          LOCAL_PATH := $(call my-dir)
          include $(CLEAR_VARS)
          LOCAL_MODULE    := SuperTool
          LOCAL_SRC_FILES := main.cpp
          LOCAL_LDLIBS    := -llog -landroid
          include $(BUILD_SHARED_LIBRARY)
          EOF

          echo "APP_ABI := arm64-v8a" > jni/Application.mk
          echo "APP_PLATFORM := android-21" >> jni/Application.mk

      - name: Build
        run: ndk-build NDK_PROJECT_PATH=. APP_BUILD_SCRIPT=jni/Android.mk APP_ABI=arm64-v8a

      - name: Upload Only SuperTool Library
        uses: actions/upload-artifact@v4
        with:
          name: libSuperTool_Final
          path: libs/arm64-v8a/libSuperTool.so